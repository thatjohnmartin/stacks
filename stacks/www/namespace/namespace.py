#     APLab utility namespace module##     Copyright (c) 2013 John Wainwright, All rights reserved.# -*- coding: utf-8 -*-class NameSpace(dict):     "a generic nested namespace or subspace, accessible via dotted-pathname indexing or nested attributes"        @classmethod    def from_dict(cls, src, subspace_name='', structured=True):        "recursively builds new NameSpace from given source dict"        result = cls(subspace_name=subspace_name, structured=structured)        for k, v in src.iteritems():            if type(v) == type({}):                result[k] = cls.from_dict(v, subspace_name=k)            else:                result[k] = v        return result        def __init__(self, subspace_name='', structured=True):        # structure namespaces unpack dotted pathname keys, unstructured don't - the latter are basic dicts with         #   some of the extra stuff NameSpace provides like subspace name-tracking etc.        super(NameSpace, self).__setattr__('_structured',  structured)        super(NameSpace, self).__setattr__('_subspace_name',  subspace_name)            def set_from_dict(self, src):        "recursively loads me with source dict, clearing first"        self.clear()        for k, v in src.iteritems():            if type(v) == type({}):                self[k] = self.__class__.from_dict(v, subspace_name=k)            else:                self[k] = v        return self            def __getitem__(self, key):        "access item in data dict, key can be dotted-pathname"        if super(NameSpace, self).__getattribute__('_structured') and  '.' in key:            # recursively follow path segs            local_key, rest_of_key = key.split('.', 1)            if local_key not in self:                # add missing intermediate levels if needed, constructing full subspace pathnames                subspace_name = (self._subspace_name + '.' if self._subspace_name else '') + local_key                self[local_key] = self.__class__(subspace_name=subspace_name)            return self[local_key][rest_of_key]        else:            return super(NameSpace, self).__getitem__(key)        def __setitem__(self, key, val):        "set item in data dict. key can be a dotted-pathname, missing intermediate levels added for you"        if super(NameSpace, self).__getattribute__('_structured') and '.' in key:            # recursively follow path segs            local_key, rest_of_key = key.split('.', 1)            if local_key not in self:                # add missing intermediate levels if needed, constructing full subspace pathnames                subspace_name = (self._subspace_name + '.' if self._subspace_name else '') + local_key                self[local_key] = self.__class__(subspace_name=subspace_name)            self[local_key][rest_of_key] = val        else:            super(NameSpace, self).__setitem__(key, val)        self._data_dirty = True            def __getattr__(self, name):        "attribute access data dict"        if name in self:            return self[name]        else:            raise AttributeError(name)            def __setattr__(self, name, val):        "attribute setting in data dict, will *not* add missing fileds or levels, use indexed access for that"        if name in self:            self[name] = val        else:            super(NameSpace, self).__setattr__(name, val)                def __contains__(self, key):        try:            self.__getitem__(key)        except KeyError:            return False        return True        def get(self, key, default=None):        "soft-fail get"        try:            return self.__getitem__(key)        except KeyError:            return default                def walk(self, full_pathname=False):        "a generator over the tree of objects in me, returning (pathname, val) tuples for each leaf value"        def _children(ns, prefix=''):            my_prefix = prefix + '.' if prefix else ''            for k, v in ns.iteritems():                if isinstance(v, NameSpace):                    for ck, v in _children(v, my_prefix + k):                        yield ck, v                else:                    yield my_prefix + k, v                       for k, v in _children(self, prefix=self._subspace_name if full_pathname else ''):            yield k, v                def pathname_for_key(self, key):        "constructs full pathname for key within this space, possibly already a named subspace"        return (self._subspace_name + '.' if self._subspace_name else '') + key    def relative_pathname(self, pathname):        "constructs self-relative pathname from full pathname"        return pathname[len(self._subspace_name + '.' if self._subspace_name else ''):]# ------ useful namespace subclasses  ------class ReadOnlyNameSpace(NameSpace):    """A read-only namespace."""    # All items must be set by calling superclass methods on NameSpace    class ReadOnlyNameSpaceError(Exception):        pass    def __setitem__(self, key, val):        raise self.ReadOnlyNameSpaceError("Cannot set items in a read-only namespace")# ------ useful virtual subspace classes  ------class VirtualSubspace(NameSpace):    "base virtual subspace"    # provides base implementations of reqd magic methods, all of which complain that subclasses need to implement        class SubspaceError(Exception):        pass        def __iter__(self):        raise self.SubspaceError("Cannot iterate subspace")        def keys(self):        raise self.SubspaceError("Cannot get subspace keys")        def __contains__(self, value):        raise self.SubspaceError("Cannot check containment in subspace")        def __len__(self):        raise self.SubspaceError("Cannot compute subspace length")        def __getitem__(self, key):        raise self.SubspaceError("Cannot get items in subspace")        def __setitem__(self, key, val):        raise self.SubspaceError("Cannot set items in subspace")