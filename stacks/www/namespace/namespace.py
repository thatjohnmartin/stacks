# Adapted from John Wainwright's namespace.py, all rights sort of reserved for him.# Stacks will have a global namespace that allows authors to pick up and use media, text, and other items (and perhaps# blocks themselves) from other personal or publicly accessible stacks and repositories.## There will be a library where you store actual things (on S3 managed by Stacks) or references to external things,# e.g. Flickr images in there. Library items are independent of individual stacks or blocks.## Perhaps useful things that get created as part of creating a block automatically get placed into the library, e.g. a# table with scope specs (or at least the CSV/JSON data).## Most things will be found in user space: a users.<username> at top level and then library and stacks subspaces:## .library#     .images#         .<name>#     .video#     .json#     .csv## .stacks#     .<stack-slug>#         .blocks#             .<block-name>#                 .type#                 .<key> (from key/value)## There is also global space but it will only have library for now. (Although eventually shared/public/global stacks# could live here.)## Examples:## users.johnw.library.images.NCG_1257_Orion_Nebula# users.johnw.library.json.main_rig# global.library.json.mounts.losmandy-34cclass NameSpace(dict): # (object, UserDict.DictMixin):    "a generic nested namespace or subspace, accessible via dotted-pathname indexing or nested attributes"        @classmethod    def from_dict(cls, src, subspace_name=''):        "recursively builds new NameSpace from given source dict"        result = cls(subspace_name=subspace_name)        for k, v in src.iteritems():            if type(v) == type({}):                result[k] = cls.from_dict(v, subspace_name=k)            else:                result[k] = v        return result        def __init__(self, subspace_name=''):        self._subspace_name = subspace_name            def set_from_dict(self, src):        "recursively loads me with source dict, clearing first"        self.clear()        for k, v in src.iteritems():            if type(v) == type({}):                self[k] = self.__class__.from_dict(v, subspace_name=k)            else:                self[k] = v        return self            def __getitem__(self, key):        "access item in data dict, key can be dotted-pathname"        if '.' in key:            val = self            for n in key.split('.'):                val = val[n]            return val        else:            return super(NameSpace, self).__getitem__(key)        def __setitem__(self, key, val):        "set item in data dict. key can be a dotted-pathname, missing intermediate levels added for you"        if '.' in key:            data = self            paths = key.split('.')            for n in paths[:-1]:                if n not in data:                    # add missing levels if needed                    data[n] = NameSpace(subspace_name=n)                data = data[n]            data[paths[-1]] = val        else:            super(NameSpace, self).__setitem__(key, val)        self._data_dirty = True            def __getattr__(self, name):        "attribute access data dict"        if name in self:            return self[name]        else:            raise AttributeError(name)            def __setattr__(self, name, val):        "attribute access to data dict, will *not* add missing levels, use indexed access for that"        if name in self:            self[name] = val        else:            super(NameSpace, self).__setattr__(name, val)                def __contains__(self, key):        try:            self.__getitem__(key)        except KeyError:            return False        return True        def get(self, key, default=None):        "soft-fail get"        try:            return self.__getitem__(key)        except KeyError:            return default                def walk(self, full_pathname=False):        "a generator over the tree of objects in me, returning (pathname, val) tuples for each leaf value"        def _children(ns, prefix=''):            my_prefix = prefix + '.' if prefix else ''            for k, v in ns.iteritems():                if isinstance(v, NameSpace):                    for ck, v in _children(v, my_prefix + k):                        yield ck, v                else:                    yield my_prefix + k, v                       for k, v in _children(self, prefix=self._subspace_name if full_pathname else ''):            yield k, v