#     APLab utility namespace module##     Copyright (c) 2013 John Wainwright, All rights reserved.# -*- coding: utf-8 -*-class NameSpace(dict): # (object, UserDict.DictMixin):    "a generic nested namespace or subspace, accessible via dotted-pathname indexing or nested attributes"        @classmethod    def from_dict(cls, src, subspace_name=''):        "recursively builds new NameSpace from given source dict"        result = cls(subspace_name=subspace_name)        for k, v in src.iteritems():            if type(v) == type({}):                result[k] = cls.from_dict(v, subspace_name=k)            else:                result[k] = v        return result        def __init__(self, subspace_name=''):        self._subspace_name = subspace_name            def set_from_dict(self, src):        "recursively loads me with source dict, clearing first"        self.clear()        for k, v in src.iteritems():            if type(v) == type({}):                self[k] = self.__class__.from_dict(v, subspace_name=k)            else:                self[k] = v        return self            def __getitem__(self, key):        "access item in data dict, key can be dotted-pathname"        if '.' in key:            val = self            for n in key.split('.'):                val = val[n]            return val        else:            return super(NameSpace, self).__getitem__(key)        def __setitem__(self, key, val):        "set item in data dict. key can be a dotted-pathname, missing intermediate levels added for you"        if '.' in key:            data = self            paths = key.split('.')            for n in paths[:-1]:                if n not in data:                    # add missing levels if needed                    data[n] = NameSpace(subspace_name=n)                data = data[n]            data[paths[-1]] = val        else:            super(NameSpace, self).__setitem__(key, val)        self._data_dirty = True            def __getattr__(self, name):        "attribute access data dict"        if name in self:            return self[name]        else:            raise AttributeError(name)            def __setattr__(self, name, val):        "attribute access to data dict, will *not* add missing levels, use indexed access for that"        if name in self:            self[name] = val        else:            super(NameSpace, self).__setattr__(name, val)                def __contains__(self, key):        try:            self.__getitem__(key)        except KeyError:            return False        return True        def get(self, key, default=None):        "soft-fail get"        try:            return self.__getitem__(key)        except KeyError:            return default                def walk(self, full_pathname=False):        "a generator over the tree of objects in me, returning (pathname, val) tuples for each leaf value"        def _children(ns, prefix=''):            my_prefix = prefix + '.' if prefix else ''            for k, v in ns.iteritems():                if isinstance(v, NameSpace):                    for ck, v in _children(v, my_prefix + k):                        yield ck, v                else:                    yield my_prefix + k, v                       for k, v in _children(self, prefix=self._subspace_name if full_pathname else ''):            yield k, v